---
title: 拦截器 Interceptor
date: 2022-12-09 17:36:46
permalink: /pages/be32b0/
categories:
  - Spring Boot
tags:
  - 
author: 
  name: Xueliang
  link: https://github.com/Human0722
---

### 过滤器和拦截器区别
![filterandinterceptor](/images/springboot/filterandinterceptor.png)

#### 过滤器 Filters
过滤器是webserver的一部分，不属于SpringFramework。可以使用过滤器来控制请求或者阻断请求。  
Spring Security就是基于过滤器实现了认证和授权。通过配置一个名为 `DelegatingFilterProxy`的拦截器, Spring Security可以拦截所有出入流量，因为基于拦截器，所以可以工作在SpringMVC 外。
#### 拦截器 HandlerInterceptors
拦截器是 `Spring MVC`的一部分，工作在 `DispatcherServlet` 和 `Controllers`之间。我们可以在 到达Controller之前、View 渲染前后对请求进行拦截处理。


### Filter的使用
通过实现接口 `javax.servlet.Filter` 定义过滤器。
```java 
@Component
public class LogFilter implements Filter {

    private Logger logger = LoggerFactory.getLogger(LogFilter.class);

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
      throws IOException, ServletException {
        logger.info("Hello from: " + request.getLocalAddr());
        chain.doFilter(request, response);
    }
}
```
通过注解 `@Component` 将过滤器加入到 Spring 容器中，容器会自动处理。

### HandlerInterceptor 的使用
在 SpringBoot 中使用拦截器分为两个步骤，首先定义一个拦截器，然后通过配置类配置拦截器。  
通过实现接口`HandlerInterceptor`定义拦截器，重写三个方法： 
- `preHandle()` 在执行 Controller 方法之前调用
- `postHandle()` 在执行 Controller的渲染 View 代码方法之前执行
- `afterCompletion()`  在执行 Controller 的渲染 View 代码方法之后执行

```java 
@Component
public class LogInterceptor implements HandlerInterceptor {

    private static Logger log =  LoggerFactory.getLogger(LogInterceptor.class);

    /**
     * 执行控制器方法前执行
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        log.info("Hello from:" + request.getLocalAddr());
        return true;
    }

    /**
     * 执行完控制器方法，但在渲染ModelAndView前执行
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    
        log.info("postHandle");
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    /**
     * 控制器方法执行完执行
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    
        log.info("afterCopletion");
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```
通过实现 `WebMvcConfigure` 的类，再将这个类放入到容器中实现对 SpringMVC的配置。
```java 
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private LogInterceptor logInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(logInterceptor);
    }
}
```
### 验证
添加一个控制器方法，访问这个方法，查看日志打印情况。
```java 
@RestController
public class TestController {

    @GetMapping("/test")
    public String handleTest() {
        return "ResponseContent";
    }
}
```
通过 `curl http://localhost:9001/test` 打印日志: 
```text 
17:18:15.452 [http-nio-9001-exec-1] INFO  i.g.human0722.demo.filter.LogFilter - Hello from:0:0:0:0:0:0:0:1
17:18:15.461 [http-nio-9001-exec-1] INFO  i.g.h.d.interceptor.LogInterceptor - Hello from:0:0:0:0:0:0:0:1
Inside Controller
17:18:15.478 [http-nio-9001-exec-1] INFO  i.g.h.d.interceptor.LogInterceptor - postHandle
17:18:15.478 [http-nio-9001-exec-1] INFO  i.g.h.d.interceptor.LogInterceptor - afterCopletion
```
可以看到执行顺序是： 自定义的拦截器、过滤器的preHandle方法、postHandle方法、afterCompletion方法。
> 如果控制器返回的是 ModelAndView 相关类型，拦截器会被执行2次。如果只想让执行1次，要在第一次执行preHandle()后对请求设置修改，标记为已经处理过，第二次判断这个标志。

### 总结
过滤器适合粒度较大的控制，比如认证直接阻断请求。   
过滤器适合粒度更新的控制，比如针对某些方法鉴权。

### 应用
#### 过滤器过滤请求
### 拦截器配合注解实现鉴权




